## 시스템 프로그래밍 관련 핵심 개념 알아두기

---
## 시스템 프로그래밍의 기반 요소
* 시스템 콜 (system call)
* C 라이브러리
* C 컴파일러
> 사용자 영역에서의 시스템 프로그래밍

---
## 시스템 콜
* 시스템콜: 운영체제 리소스나 서비스 요청을 위해, 사용자 영역에서 커널 영역으로 들어가는 함수
* 주요 시스템콜 : read(), write(), open() 등
> 리눅스/유닉스는 C언어로 만들어져 있으므로, 시스템콜도 C언어로 구현

---
## 시스템콜은 어떻게 구현?
* eax 레지스터에 시스템 콜 번호를 넣고,
* ebx 레지스터에는 시스템콜에 해당하는 인자값을 넣고
* 소프트웨어 인터럽트 명령을 호출하면서 0x80 값을 넘겨줌
```
mov eax, 1  // 시스템콜 번호
mov ebx, 0  // 함수 인자
int 0x80    // 소프트웨어 인터럽트 명령
```

1. CPU는 사용자 모드를 커널 모드로 바꿔줌
2. IDT(Interrupt Descriptor Table)에서 0x80에 해당하는 주소 함수를 찾아서 실행함
3. system_call() 함수에서 eax로부터 시스템 콜 번호를 찾아서 해당 번호에 맞는 시스템콜 함수로 이동
4. 해당 시스템콜 함수 실행 후 다시 커널모드에서 사용자 모드로 변경하고, 다시 해당 프로세스 댜음 코드 진행

| %eax | kernel function (system call) | %ebx           |
|------|-------------------------------|----------------|
| 1    | sys_exit (exit)               | int            |
| 2    | sys_fork (fork)               | struct pt_regs |
| 3    | sys_read (read)               | unsigned int   |
| 4    | sys_write (write)             | unsigned int   |
| 5    | sys_open (open)               | const char*    |

## API
* 응용 프로그램과 분리된 하위 호환 인터페이스
    + 예: 시스템 콜 래퍼, 입출력 라이브러리등
    + 동적 라이브러리 : 이미 컴파일이 된 상태로 바이너리 형태로 있다.
        - 실제로 프로세스에서 필요할 때 해당 소스를 이용하게끔 되어있다.
    + 정적 라이브러리 : 이미 컴파일이 된 상태로 바이너리 형태로 있다.
        - 프로그램에서 특정 라이브러리의 함수를 호출하면 이 라이브러리를 다시 컴파일을 하는 것이 아니라 이 라이브러리에 있는 바이너리에다가 실행파일의 코드를 붙인다.
    + API 라이브러리는 응용프로그램과 분리되어있다.
        - 수정을 할 때 응용프로그램을 건들지 않고 라이브러리만 수정하여 기능 업데이트를 할 수 있다.