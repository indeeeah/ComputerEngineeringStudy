## 페이지 교체 정책 (page replacement policy)
* 운영체제가 특정 페이지를 물리 메모리에 올리려 하는데 물리 메모리가 다 차 있다면?
    + 기존 페이지 중 하나를 물리 메모리에서 저장 매체로 내리고(저장)
    + 새로운 페이지를 해당 물리 메모리 공간에 올린다.

---
## 페이지 교체 알고리즘 (FIFO)
* FIFO Page Replacement Algorithm
    + 가장 먼저 들어온 페이지를 내리자
    + 가장 먼저 들어온 페이지에 덮어씌운다.

## 페이지 교체 알고리즘 (OPT)
* 최적 페이지 교체 알고리즘 (OPTimal Replacement Algorithm)
    + 앞으로 가장 오랫동안 사용하지 않을 페이지를 내리자
    + 일반 OS에서는 구현 불가. 불가능한 알고리즘

| OTP             |   |   |   |   |   |       |   |   |   |   |
|-----------------|---|---|---|---|---|-------|---|---|---|---|
| Requested Page  | 1 | 2 | 3 | 2 | 1 | 4     | 1 | 2 | 4 | 1 |
| Physical Memory | 1 | 1 | 1 | 1 | 1 | 1     |   |   |   |   |
|                 |   | 2 | 2 | 2 | 2 | 2     |   |   |   |   |
|                 |   |   | 3 | 3 | 3 | **4** |   |   |   |   |
* 이후에 3 page는 쓰지 않을 것이기 때문에 3에 4를 덮어씌여준다.

## 페이지 겨체 알고리즘 (LRU)
* LRU(Least Recently Used) Page Replacement Algorithm
    + 가장 오래 전에 사용된 페이지를 교체
        - 지금은 사용이 되지 않을 가능성이 높다.
    + OPT 교체 알고리즘이 구현이 불가하므로, 과거 기록을 기반으로 시도
    * 가장 많이 사용한다.

| LRU             |   |   |   |   |   |       |   |   |   |   |
|-----------------|---|---|---|---|---|-------|---|---|---|---|
| Requested Page  | 1 | 2 | 3 | 2 | 1 | 4     | 1 | 2 | 4 | 1 |
| Physical Memory | 1 | 1 | 1 | 1 | 1 | 1     |   |   |   |   |
|                 |   | 2 | 2 | 2 | 2 | 2     |   |   |   |   |
|                 |   |   | 3 | 3 | 3 | **4** |   |   |   |   |

* 1번은 바로 전에 사용했고, 2번도 그 전에 사용했고, 3이 가장 오래 전에 사용했기 때문에 3에 4를 덮어씌여준다.

## 페이지 스왑 알고리즘 (LFU)
* LFU(Least Frequently Used) Page Replacement Algorithm
    + 가장 적게 사용된 페이지를 내리자

| LFU             |   |   |   |   |   |   |   |   |   |       |
|-----------------|---|---|---|---|---|---|---|---|---|-------|
| Requested Page  | 1 | 2 | 3 | 2 | 1 | 3 | 1 | 2 | 1 | 4     |
| Physical Memory | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1 | 1     |
|                 |   | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2 | 2     |
|                 |   |   | 3 | 3 | 3 | 3 | 3 | 3 | 3 | **4** |

* 3번이 두번밖에 안쓰였으니까 3에 4를 덮어씌운다.

## 페이지 스왑 알고리즘 (NUR)
* NUR(Not Used Recently) Page Replacement Algorithm
    + LRU와 마찬가지로 최근에 사용하지 않은 페이지부터 교체하는 기법
    + 각 페이지마다 참조 비트(R), 수정 비트(M)을 둠 (R, M)
        - (0, 0), (0, 1), (1, 0), (1, 1) 순으로 페이지 교체

| LFU             | read | read | read | read | read | write | write | read | write | read  |
|-----------------|------|------|------|------|------|-------|-------|------|-------|-------|
| Requested Page  | 1    | 2    | 3    | 2    | 1    | 3     | 1     | 2    | 1     | 4     |
| Physical Memory | 1    | 1    | 1    | 1    | 1    | 1     | 1     | 1    | 1     | 1     |
|                 |      | 2    | 2    | 2    | 2    | 2     | 2     | 2    | 2     | **4** |
|                 |      |      | 3    | 3    | 3    | 3     | 3     | 3    | 3     | 3     |

| Page | 참조비트 | 수정비트 |
|------|----------|----------|
| 1    | 1        | 1        |
| 2    | 1        | 0        |
| 3    | 1        | 1        |

* 2번의 (1, 0)이 가장 최근에 사용하지 않았으므로 4번과 바꿔준다.

---
## 스레싱(Thrashing)
* 반복적으로 페이지 폴트가 발생해서 과도하게 페이지 교체 작업이 일어나 실제로는 아무일도 하지 못하는 상황